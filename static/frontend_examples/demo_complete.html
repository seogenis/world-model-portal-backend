<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmos Video Generator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        
        h1, h2, h3 {
            color: #333;
        }
        
        .container {
            background-color: #f9f9f9;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        /* Tab navigation */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        
        .tab.active {
            background-color: white;
            border-bottom: 2px solid #4CAF50;
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 0 4px 4px 4px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Form elements */
        textarea {
            width: 100%;
            height: 150px;
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: inherit;
            font-size: 14px;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        /* Progress indicators */
        .status {
            font-weight: bold;
            margin-right: 10px;
        }
        
        .status-pending { color: #888; }
        .status-generating { color: #ff9800; }
        .status-processing { color: #2196F3; }
        .status-complete { color: #4CAF50; }
        .status-failed { color: #f44336; }
        
        progress {
            width: 100%;
            height: 20px;
            margin-top: 10px;
            margin-bottom: 20px;
        }
        
        /* Log container */
        .log-container {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            font-family: monospace;
            font-size: 13px;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        
        /* Video containers */
        .video-container {
            margin-top: 20px;
        }
        
        video {
            max-width: 100%;
            max-height: 400px;
            border-radius: 4px;
            background-color: #000;
            display: none;
        }
        
        /* Batch grid */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            grid-gap: 20px;
            margin-top: 20px;
        }
        
        .grid-item {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }
        
        .prompt-display {
            font-size: 12px;
            color: #555;
            height: 60px;
            overflow-y: auto;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: #4CAF50;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }
        
        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            grid-gap: 10px;
            margin-top: 15px;
            margin-bottom: 15px;
        }
        
        .parameter-item {
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 8px;
            background-color: #f9f9f9;
        }
        
        .parameter-name {
            font-weight: bold;
            font-size: 14px;
            color: #555;
            margin-bottom: 4px;
        }
        
        .parameter-value {
            font-size: 13px;
        }
        
        .change-item {
            margin-bottom: 5px;
            padding: 5px;
            background-color: #e8f5e9;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .variation-container {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .variation-item {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            flex: 1 0 calc(33.333% - 10px);
            min-width: 200px;
            box-sizing: border-box;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .variation-item:hover {
            background-color: #f0f0f0;
        }
        
        .variation-item.selected {
            background-color: #e1f5fe;
            border-color: #2196F3;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>Cosmos Video Generator</h1>
    <p>Generate videos from text prompts using NVIDIA's Cosmos text-to-video model.</p>
    
    <!-- Tab Navigation -->
    <div class="tabs">
        <div class="tab active" id="single-tab">Single Video Generation</div>
        <div class="tab" id="batch-tab">Batch Generation (Multiple GPUs)</div>
        <div class="tab" id="prompt-tab">Prompt Enhancement</div>
        <div class="tab" id="parameter-tab">Parameter Extraction</div>
        <div class="tab" id="update-tab">Prompt Updates</div>
        <div class="tab" id="variation-tab">Prompt Variations</div>
        <div class="tab" id="session-tab">Session Management</div>
    </div>
    
    <!-- Single Video Generation Tab -->
    <div class="tab-content active" id="single-content">
        <h2>Single Video Generation</h2>
        <p>Generate a high-quality video from a text prompt.</p>
        
        <textarea id="single-prompt" placeholder="Enter your text-to-video prompt here...">A photorealistic cinematic scene of a futuristic city with flying cars and holographic billboards at night, with rain-slicked streets reflecting neon lights.</textarea>
        
        <div>
            <button id="single-generate-btn">Generate Video</button>
            <button id="single-clear-log-btn">Clear Log</button>
        </div>
        
        <div id="single-status-container">
            <h3>Status: <span id="single-status-text" class="status">Ready</span></h3>
            <progress id="single-progress-bar" value="0" max="100"></progress>
        </div>
        
        <div class="video-container">
            <video id="single-video" controls>
                Your browser does not support the video tag.
            </video>
        </div>
        
        <h3>Status Log</h3>
        <div id="single-log-container" class="log-container"></div>
    </div>
    
    <!-- Batch Video Generation Tab -->
    <div class="tab-content" id="batch-content">
        <h2>Batch Video Generation</h2>
        <p>Generate up to 8 videos simultaneously, each on a separate GPU.</p>
        
        <textarea id="batch-prompts" placeholder="Enter up to 8 prompts, one per line. Each prompt will be processed on a separate GPU.">A sleek humanoid robot working in a high-tech warehouse, organizing packages on metal shelves.
Three matte-black quad-rotor drones hover over a rugged mountain slope at dawn.
A teal robot chef preparing a gourmet meal in a modern kitchen.
A vintage red convertible driving down a coastal highway at sunset.</textarea>
        
        <button id="batch-generate-btn">Generate Videos</button>
        
        <h3>Batch Status: <span id="batch-status-text" class="status">Ready</span></h3>
        <div class="grid-container" id="batch-grid">
            <!-- Grid items will be generated dynamically -->
        </div>
        
        <div id="batch-download-container" style="display: none; margin-top: 20px; text-align: center;">
            <button id="batch-download-btn">Download All Videos</button>
        </div>
    </div>
    
    <!-- Prompt Enhancement Tab -->
    <div class="tab-content" id="prompt-content">
        <h2>Prompt Enhancement</h2>
        <p>Transform basic ideas into detailed, high-quality prompts for better video generation.</p>
        
        <textarea id="rough-prompt" placeholder="Enter a simple prompt to enhance (e.g., 'dog running')">dog running</textarea>
        
        <button id="enhance-btn">Enhance Prompt</button>
        
        <div id="enhanced-result" style="margin-top: 20px; display: none;">
            <h3>Enhanced Prompt:</h3>
            <div id="enhanced-prompt-container" style="border: 1px solid #ddd; padding: 15px; border-radius: 4px; background-color: #f9f9f9;">
                <p id="enhanced-prompt"></p>
            </div>
            <button id="use-enhanced-btn" style="margin-top: 10px;">Use This Prompt</button>
        </div>
    </div>
    
    <!-- Parameter Extraction Tab -->
    <div class="tab-content" id="parameter-content">
        <h2>Parameter Extraction</h2>
        <p>Extract key parameters from your prompt to help with refinement.</p>
        
        <textarea id="parameter-prompt" placeholder="Enter a detailed prompt to extract parameters...">A beautiful sunset over a calm ocean with golden light reflecting off gentle waves, seagulls flying in the distance against a purple and orange sky.</textarea>
        
        <button id="extract-btn">Extract Parameters</button>
        
        <div id="parameters-result" style="margin-top: 20px; display: none;">
            <h3>Extracted Parameters:</h3>
            <div id="parameters-container" class="parameter-grid">
                <!-- Parameters will be populated here -->
            </div>
        </div>
    </div>
    
    <!-- Prompt Update Tab -->
    <div class="tab-content" id="update-content">
        <h2>Update Prompt</h2>
        <p>Refine your prompt using natural language requests.</p>
        
        <div id="current-prompt-container" style="margin-bottom: 20px;">
            <h3>Current Prompt:</h3>
            <div id="current-prompt" style="border: 1px solid #ddd; padding: 15px; border-radius: 4px; background-color: #f9f9f9;">
                <p>No prompt initialized yet. Please use the Parameter Extraction tab first.</p>
            </div>
        </div>
        
        <textarea id="update-request" placeholder="Enter a request like 'make it more dramatic' or 'add some clouds'">Make it more dramatic with stormy weather.</textarea>
        
        <button id="update-btn">Update Prompt</button>
        
        <div id="update-result" style="margin-top: 20px; display: none;">
            <h3>Updated Prompt:</h3>
            <div id="updated-prompt-container" style="border: 1px solid #ddd; padding: 15px; border-radius: 4px; background-color: #f9f9f9;">
                <p id="updated-prompt"></p>
            </div>
            
            <h3>Changes Made:</h3>
            <div id="changes-container">
                <!-- Changes will be populated here -->
            </div>
            
            <button id="use-updated-btn" style="margin-top: 10px;">Use This Prompt</button>
        </div>
    </div>
    
    <!-- Prompt Variations Tab -->
    <div class="tab-content" id="variation-content">
        <h2>Generate Prompt Variations</h2>
        <p>Create multiple variations based on your prompt history.</p>
        
        <div id="history-container" style="margin-bottom: 20px;">
            <h3>Prompt History:</h3>
            <div id="history-list" style="border: 1px solid #ddd; padding: 15px; border-radius: 4px; max-height: 200px; overflow-y: auto;">
                <p>No prompt history yet. Please initialize and update prompts first.</p>
            </div>
        </div>
        
        <div id="selection-controls" style="margin-bottom: 20px;">
            <label for="variations-count">Number of variations to generate:</label>
            <select id="variations-count" style="padding: 5px; margin-left: 10px;">
                <option value="3">3</option>
                <option value="5">5</option>
                <option value="8">8</option>
            </select>
            <button id="generate-variations-btn" style="margin-left: 10px;">Generate Variations</button>
        </div>
        
        <div id="variations-result" style="margin-top: 20px; display: none;">
            <h3>Generated Variations:</h3>
            <div id="variations-container" class="variation-container">
                <!-- Variations will be populated here -->
            </div>
            
            <button id="use-variation-btn" style="margin-top: 20px;">Use Selected Variation</button>
        </div>
    </div>
    
    <!-- Session Management Tab -->
    <div class="tab-content" id="session-content">
        <h2>Session Management</h2>
        <p>Manage your prompt sessions and history.</p>
        
        <div style="margin-bottom: 20px;">
            <h3>Current Session</h3>
            <div id="current-session-info" style="border: 1px solid #ddd; padding: 15px; border-radius: 4px; background-color: #f9f9f9;">
                <p>Session ID: <span id="current-session-id">None</span></p>
            </div>
            
            <div style="margin-top: 15px; display: flex; gap: 10px;">
                <button id="new-session-btn">Create New Session</button>
                <button id="clear-session-btn">Clear Session Data</button>
            </div>
        </div>
        
        <div style="margin-top: 30px;">
            <h3>Active Sessions</h3>
            <button id="list-sessions-btn">List All Sessions</button>
            
            <div id="sessions-list" style="margin-top: 15px; border: 1px solid #ddd; padding: 15px; border-radius: 4px; max-height: 300px; overflow-y: auto; display: none;">
                <!-- Sessions will be listed here -->
            </div>
        </div>
    </div>
    
    <script>
        // Set up API URL based on environment
        // Note: The API base path should match settings.API_PREFIX in the backend config
        const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
            ? `http://${window.location.host}/api` 
            : `https://${window.location.host}/api`;
            
        // Helper function to detect and report API errors
        async function handleApiResponse(response, errorMessage = "API Error") {
            if (!response.ok) {
                // Try to get error details from response
                let errorDetails = "";
                try {
                    const errorData = await response.json();
                    errorDetails = errorData.detail || `Status: ${response.status}`;
                } catch (e) {
                    errorDetails = `Status: ${response.status}`;
                }
                throw new Error(`${errorMessage}: ${errorDetails}`);
            }
            return await response.json();
        }
        
        // Tab switching functionality
        const tabs = ['single-tab', 'batch-tab', 'prompt-tab', 'parameter-tab', 'update-tab', 'variation-tab', 'session-tab'];
        const contents = ['single-content', 'batch-content', 'prompt-content', 'parameter-content', 'update-content', 'variation-content', 'session-content'];
        
        tabs.forEach((tabId, index) => {
            const tab = document.getElementById(tabId);
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and contents
                tabs.forEach(t => document.getElementById(t).classList.remove('active'));
                contents.forEach(c => document.getElementById(c).classList.remove('active'));
                
                // Add active class to clicked tab and corresponding content
                tab.classList.add('active');
                document.getElementById(contents[index]).classList.add('active');
                
                // Special handling for specific tabs
                if (tabId === 'variation-tab') {
                    // Auto-load history when switching to variations tab
                    const currentSessionId = getSessionId();
                    if (currentSessionId && (!promptHistory || promptHistory.length === 0)) {
                        console.log('Loading history for variations tab');
                        loadSessionHistory(currentSessionId).then(() => {
                            updateHistoryList();
                        }).catch(e => {
                            console.error('Error loading history:', e);
                        });
                    } else {
                        // Refresh the history display
                        updateHistoryList();
                    }
                }
            });
        });
        
        // -------------------- Single Video Generation --------------------
        
        // Get DOM elements for single video generation
        const singlePrompt = document.getElementById('single-prompt');
        const singleGenerateBtn = document.getElementById('single-generate-btn');
        const singleClearLogBtn = document.getElementById('single-clear-log-btn');
        const singleStatusText = document.getElementById('single-status-text');
        const singleProgressBar = document.getElementById('single-progress-bar');
        const singleLogContainer = document.getElementById('single-log-container');
        const singleVideo = document.getElementById('single-video');
        
        // Polling configuration
        const SINGLE_POLL_INTERVAL = 2000; // 2 seconds
        let currentSingleJobId = null;
        let singlePollingActive = false;
        
        // Add event listeners
        singleGenerateBtn.addEventListener('click', startSingleVideoGeneration);
        singleClearLogBtn.addEventListener('click', () => {
            singleLogContainer.innerHTML = '';
        });
        
        // Start single video generation
        async function startSingleVideoGeneration() {
            // Validate input
            const prompt = singlePrompt.value.trim();
            if (!prompt) {
                alert('Please enter a prompt');
                return;
            }
            
            // Reset UI
            singleGenerateBtn.innerHTML = 'Generating...<span class="loading"></span>';
            singleProgressBar.value = 0;
            singleVideo.style.display = 'none';
            singleVideo.src = '';
            singleStatusText.textContent = 'Submitting...';
            singleStatusText.className = 'status';
            
            try {
                // Log the action
                addSingleLogEntry('info', 'Starting video generation...');
                
                // Call API to start video generation
                const response = await fetch(`${API_BASE_URL}/video/single_inference`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        prompt: prompt
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                currentSingleJobId = data.job_id;
                addSingleLogEntry('info', `Job created with ID: ${currentSingleJobId}`);
                singleGenerateBtn.textContent = 'Generating... (Switch tabs safely)';
                
                // Start polling for status updates
                fallbackToPolling(currentSingleJobId);
                
            } catch (error) {
                addSingleLogEntry('error', `Error: ${error.message}`);
                singleStatusText.textContent = 'Error';
                singleStatusText.className = 'status status-failed';
                singleGenerateBtn.textContent = 'Generate Video';
            }
        }
        
        // Legacy function kept for compatibility but now just calls fallbackToPolling
        function startSinglePolling(jobId) {
            fallbackToPolling(jobId);
        }
        
        // Connect to WebSocket for status updates
        function connectToWebSocket(jobId) {
            // Determine WebSocket URL (ws or wss based on current protocol)
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsBaseUrl = `${wsProtocol}//${window.location.host}`;
            const wsUrl = `${wsBaseUrl}/api/ws/video/${jobId}`;
            
            addSingleLogEntry('info', `Connecting to WebSocket at ${wsUrl}`);
            
            // Create WebSocket connection
            let socket;
            try {
                socket = new WebSocket(wsUrl);
            } catch (e) {
                addSingleLogEntry('error', `Failed to create WebSocket: ${e.message}`);
                fallbackToPolling(jobId);
                return;
            }
            
            // Set timeout for WebSocket connection
            const connectionTimeout = setTimeout(() => {
                if (socket.readyState !== WebSocket.OPEN) {
                    addSingleLogEntry('error', 'WebSocket connection timed out');
                    socket.close();
                    fallbackToPolling(jobId);
                }
            }, 10000); // 10 second timeout
            
            // Connection opened
            socket.addEventListener('open', (event) => {
                addSingleLogEntry('info', 'WebSocket connection established');
                clearTimeout(connectionTimeout); // Clear timeout once connected
            });
            
            // Listen for messages
            socket.addEventListener('message', (event) => {
                try {
                    const statusData = JSON.parse(event.data);
                    console.log('WebSocket update:', statusData);
                    
                    // Update UI with status
                    updateSingleStatus(statusData);
                    
                    // Check if we should close WebSocket
                    if (statusData.status === 'complete' || statusData.status === 'failed') {
                        addSingleLogEntry('info', `Job ${jobId} ${statusData.status}, closing WebSocket`);
                        singlePollingActive = false;
                        singleGenerateBtn.textContent = 'Generate Video';
                        socket.close();
                    }
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                    addSingleLogEntry('error', `Error parsing WebSocket message: ${error.message}`);
                }
            });
            
            // Connection closed
            socket.addEventListener('close', (event) => {
                clearTimeout(connectionTimeout); // Clear timeout if it hasn't fired
                
                const reason = event.reason ? `: ${event.reason}` : '';
                addSingleLogEntry('info', `WebSocket connection closed${reason}`);
                
                // If closed unexpectedly and we're still expecting updates, fall back to polling
                if (singlePollingActive) {
                    addSingleLogEntry('info', 'WebSocket closed unexpectedly, falling back to polling');
                    fallbackToPolling(jobId);
                } else {
                    singlePollingActive = false;
                }
            });
            
            // Connection error
            socket.addEventListener('error', (error) => {
                addSingleLogEntry('error', `WebSocket error: ${error.message || 'Unknown error'}`);
                console.error('WebSocket error:', error);
                
                // Fall back to polling on WebSocket error
                if (singlePollingActive) {
                    fallbackToPolling(jobId);
                }
                singlePollingActive = false;
            });
            
            return socket;
        }
        
        // Fallback to traditional polling if WebSocket fails
        function fallbackToPolling(jobId) {
            addSingleLogEntry('info', `Falling back to polling for status updates...`);
            
            // Prevent double fallbacks
            if (!singlePollingActive) {
                singlePollingActive = true;
                
                // Use the traditional polling approach
                pollSingleStatus(jobId);
            }
        }
        
        // Poll for single video status as fallback (traditional method)
        function pollSingleStatus(jobId) {
            // Don't start polling if it's already active
            if (!singlePollingActive) {
                singlePollingActive = true;
                addSingleLogEntry('info', `Starting status polling for job ${jobId}...`);
            }
            
            // Always ensure we have the current job ID stored
            currentSingleJobId = jobId;
            
            // Use setTimeout instead of blocking with while loop
            // This allows other UI interactions to happen while polling
            const pollOnce = async () => {
                try {
                    // Fetch status from API
                    addSingleLogEntry('info', `Polling for status update...`);
                    const response = await fetch(`${API_BASE_URL}/video/status/${jobId}`);
                    
                    if (!response.ok) {
                        if (response.status === 404) {
                            addSingleLogEntry('error', `Job ${jobId} not found`);
                        } else {
                            addSingleLogEntry('error', `API error: ${response.status}`);
                        }
                        singlePollingActive = false;
                        singleStatusText.textContent = 'Error';
                        singleStatusText.className = 'status status-failed';
                        singleGenerateBtn.textContent = 'Generate Video';
                        return; // Stop polling
                    }
                    
                    const statusData = await response.json();
                    
                    // Update UI with status
                    updateSingleStatus(statusData);
                    
                    // Check if we should stop polling
                    if (statusData.status === 'complete' || statusData.status === 'failed') {
                        singlePollingActive = false;
                        singleGenerateBtn.textContent = 'Generate Video';
                        
                        // If complete but no video showing, try once more with our fallback logic
                        if (statusData.status === 'complete' && singleVideo.style.display !== 'block') {
                            addSingleLogEntry('info', `Job complete but video not showing, triggering manual video load`);
                            updateSingleStatus({
                                status: 'complete',
                                message: 'Video generation complete',
                                progress: 100,
                                video_url: statusData.video_url
                            });
                        }
                        
                        return; // Stop polling
                    } 
                    
                    // Continue polling
                    if (singlePollingActive) {
                        setTimeout(pollOnce, SINGLE_POLL_INTERVAL);
                    }
                } catch (error) {
                    console.error('Error polling status:', error);
                    addSingleLogEntry('error', `Polling error: ${error.message}`);
                    
                    // Don't immediately fail - give it a few more tries
                    if (singlePollingActive) {
                        addSingleLogEntry('info', `Will retry polling in ${SINGLE_POLL_INTERVAL/1000} seconds...`);
                        setTimeout(pollOnce, SINGLE_POLL_INTERVAL);
                    } else {
                        singleStatusText.textContent = 'Error';
                        singleStatusText.className = 'status status-failed';
                        singleGenerateBtn.textContent = 'Generate Video';
                    }
                }
            };
            
            // Start the polling process
            pollOnce();
        }
        
        // Update UI with single video status data
        function updateSingleStatus(data) {
            // Get status data
            const status = data.status;
            const message = data.message;
            const progress = data.progress;
            const videoUrl = data.video_url;
            
            // Log the update
            addSingleLogEntry(status, `${getStatusText(status)}: ${message} (${progress}%)`);
            
            // Update status text
            singleStatusText.textContent = getStatusText(status);
            singleStatusText.className = `status status-${status}`;
            
            // Update progress bar
            singleProgressBar.value = progress;
            
            // If video is complete, show it
            if (status === 'complete') {
                // Handle case where videoUrl might be missing
                let finalVideoUrl = videoUrl;
                if (!finalVideoUrl && currentSingleJobId) {
                    // Use direct static path as instructed
                    finalVideoUrl = `/static/videos/${currentSingleJobId}/video.mp4`;
                    addSingleLogEntry('info', `Using direct static path: ${finalVideoUrl}`);
                }
                
                if (finalVideoUrl) {
                    // Try to load the video
                    singleVideo.src = finalVideoUrl;
                    singleVideo.style.display = 'block';
                    singleVideo.onloadeddata = () => {
                        addSingleLogEntry('complete', `Video loaded successfully and ready for playback`);
                        singleVideo.play();
                    };
                    
                    // Simple error handler - since we're already using the direct path
                    singleVideo.onerror = () => {
                        addSingleLogEntry('error', `Error loading video from ${finalVideoUrl}.`);
                        
                        // Try legacy format as fallback
                        if (currentSingleJobId) {
                            const fallbackUrl = `/static/videos/${currentSingleJobId}.mp4`;
                            addSingleLogEntry('info', `Trying fallback URL: ${fallbackUrl}`);
                            singleVideo.src = fallbackUrl;
                            
                            // Final error handler
                            singleVideo.onerror = () => {
                                addSingleLogEntry('error', `Video loading failed. The video may still be processing or could not be generated correctly.`);
                                
                                // Display the video path for debugging
                                addSingleLogEntry('info', `Expected video path: /static/videos/${currentSingleJobId}/video.mp4`);
                            };
                        }
                    };
                    
                    // Log the video URL attempt
                    addSingleLogEntry('info', `Attempting to load video from: ${finalVideoUrl}`);
                    
                    // Set a reload timer if video doesn't load
                    setTimeout(() => {
                        if (singleVideo.readyState === 0) { // Video hasn't started loading
                            addSingleLogEntry('info', 'Video not loading after timeout, trying reload...');
                            singleVideo.load(); // Force reload
                            
                            // Add a second timer for a final check if video is still not loading
                            setTimeout(() => {
                                if (singleVideo.readyState === 0) { 
                                    // We're already using the direct path, just force a reload
                                    addSingleLogEntry('info', 'Video still not loading after second timeout, forcing another reload...');
                                    singleVideo.load();
                                    
                                    // Display path for debugging
                                    addSingleLogEntry('info', `Expected video path: /static/videos/${currentSingleJobId}/video.mp4`);
                                }
                            }, 3000);
                        }
                    }, 2000);
                } else {
                    addSingleLogEntry('error', 'Video URL not provided in response');
                }
            }
        }
        
        // Add log entry to single video log
        function addSingleLogEntry(status, message) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            
            const timestamp = new Date().toLocaleTimeString();
            
            const statusSpan = document.createElement('span');
            statusSpan.className = `status status-${status}`;
            statusSpan.textContent = status.toUpperCase();
            
            entry.appendChild(statusSpan);
            entry.appendChild(document.createTextNode(` [${timestamp}] ${message}`));
            
            singleLogContainer.appendChild(entry);
            singleLogContainer.scrollTop = singleLogContainer.scrollHeight;
        }
        
        // -------------------- Batch Video Generation --------------------
        
        // Get DOM elements for batch video generation
        const batchPrompts = document.getElementById('batch-prompts');
        const batchGenerateBtn = document.getElementById('batch-generate-btn');
        const batchStatusText = document.getElementById('batch-status-text');
        const batchGrid = document.getElementById('batch-grid');
        const batchDownloadContainer = document.getElementById('batch-download-container');
        const batchDownloadBtn = document.getElementById('batch-download-btn');
        
        // Batch polling configuration
        const BATCH_POLL_INTERVAL = 3000; // 3 seconds
        let currentBatchId = null;
        let batchPollingActive = false;
        
        // Add event listeners
        batchGenerateBtn.addEventListener('click', startBatchVideoGeneration);
        
        // Initialize batch grid
        function initializeBatchGrid(prompts) {
            // Clear existing items
            batchGrid.innerHTML = '';
            batchDownloadContainer.style.display = 'none';
            
            // Create grid items for each prompt
            prompts.forEach((prompt, index) => {
                const gridItem = document.createElement('div');
                gridItem.className = 'grid-item';
                gridItem.id = `batch-item-${index}`;
                
                gridItem.innerHTML = `
                    <div class="prompt-display">${prompt}</div>
                    <div class="status status-pending" id="batch-status-${index}">Waiting...</div>
                    <progress value="0" max="100" id="batch-progress-${index}"></progress>
                    <video controls id="batch-video-${index}" style="display: none;"></video>
                `;
                
                batchGrid.appendChild(gridItem);
            });
        }
        
        // Start batch video generation
        async function startBatchVideoGeneration() {
            // Get prompts (split by newline, trim, filter empty)
            const promptList = batchPrompts.value
                .split('\n')
                .map(p => p.trim())
                .filter(p => p.length > 0);
            
            if (promptList.length === 0) {
                alert('Please enter at least one prompt');
                return;
            }
            
            if (promptList.length > 8) {
                alert('Maximum 8 prompts allowed. Extra prompts will be ignored.');
                promptList.length = 8; // Limit to 8 prompts
            }
            
            // Update UI during processing
            batchGenerateBtn.innerHTML = 'Generating...<span class="loading"></span>';
            
            // Reset UI
            batchStatusText.textContent = 'Submitting...';
            batchStatusText.className = 'status';
            
            // Initialize grid
            initializeBatchGrid(promptList);
            
            try {
                // Submit batch request
                const response = await fetch(`${API_BASE_URL}/video/batch_inference`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        prompts: promptList
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                currentBatchId = data.batch_id;
                
                // Update status
                batchStatusText.textContent = `Batch ${currentBatchId} started`;
                batchGenerateBtn.textContent = 'Generating... (Switch tabs safely)';
                
                // Start polling for status updates
                fallbackToBatchPolling(currentBatchId);
                
            } catch (error) {
                console.error('Error starting batch processing:', error);
                batchStatusText.textContent = `Error: ${error.message}`;
                batchStatusText.className = 'status status-failed';
                batchGenerateBtn.textContent = 'Generate Videos';
            }
        }
        
        // Legacy function kept for compatibility but now just calls fallbackToBatchPolling 
        function startBatchPolling(batchId) {
            fallbackToBatchPolling(batchId);
        }
        
        // Connect to WebSocket for batch status updates
        function connectToBatchWebSocket(batchId) {
            // Determine WebSocket URL (ws or wss based on current protocol)
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsBaseUrl = `${wsProtocol}//${window.location.host}`;
            const wsUrl = `${wsBaseUrl}/api/ws/batch/${batchId}`;
            
            console.log(`Connecting to batch WebSocket at ${wsUrl}`);
            
            // Create WebSocket connection
            let socket;
            try {
                socket = new WebSocket(wsUrl);
            } catch (e) {
                console.error(`Failed to create batch WebSocket: ${e.message}`);
                fallbackToBatchPolling(batchId);
                return;
            }
            
            // Set timeout for WebSocket connection
            const connectionTimeout = setTimeout(() => {
                if (socket.readyState !== WebSocket.OPEN) {
                    console.error('Batch WebSocket connection timed out');
                    socket.close();
                    fallbackToBatchPolling(batchId);
                }
            }, 10000); // 10 second timeout
            
            // Connection opened
            socket.addEventListener('open', (event) => {
                console.log('Batch WebSocket connection established');
                clearTimeout(connectionTimeout); // Clear timeout once connected
            });
            
            // Listen for messages
            socket.addEventListener('message', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log('Batch WebSocket update:', data);
                    
                    // Update UI with batch status
                    updateBatchUI(data);
                    
                    // Check if batch is complete, failed, or partial
                    if (data.status === 'complete' || data.status === 'failed' || data.status === 'partial') {
                        batchPollingActive = false;
                        batchGenerateBtn.textContent = 'Generate Videos';
                        
                        // Show download button if there are completed videos
                        if (data.completed > 0) {
                            batchDownloadContainer.style.display = 'block';
                            batchDownloadBtn.textContent = `Download All Videos (${data.completed})`;
                            batchDownloadBtn.onclick = () => {
                                window.location.href = `${API_BASE_URL}/video/batch_download/${batchId}`;
                            };
                        }
                        
                        // Close WebSocket
                        socket.close();
                    }
                } catch (error) {
                    console.error('Error parsing batch WebSocket message:', error);
                }
            });
            
            // Connection closed
            socket.addEventListener('close', (event) => {
                clearTimeout(connectionTimeout); // Clear timeout if it hasn't fired
                
                const reason = event.reason ? `: ${event.reason}` : '';
                console.log(`Batch WebSocket connection closed${reason}`);
                
                // If closed unexpectedly and still waiting for completion, fall back to polling
                if (batchPollingActive) {
                    console.log('Batch WebSocket closed unexpectedly, falling back to polling');
                    fallbackToBatchPolling(batchId);
                } else {
                    batchPollingActive = false;
                }
            });
            
            // Connection error
            socket.addEventListener('error', (error) => {
                console.error('Batch WebSocket error:', error);
                
                // Fall back to polling on WebSocket error
                if (batchPollingActive) {
                    fallbackToBatchPolling(batchId);
                }
                batchPollingActive = false;
            });
            
            return socket;
        }
        
        // Fallback to traditional polling for batch if WebSocket fails
        function fallbackToBatchPolling(batchId) {
            console.log(`Falling back to polling for batch ${batchId} status updates...`);
            
            // Prevent double fallbacks
            if (!batchPollingActive) {
                batchPollingActive = true;
                
                // Use the traditional polling approach
                pollBatchStatus(batchId);
            }
        }
        
        // Poll for batch status updates (traditional fallback method)
        function pollBatchStatus(batchId) {
            // Use setTimeout pattern for non-blocking polling
            const pollOnce = async () => {
                try {
                    // Fetch batch status
                    const response = await fetch(`${API_BASE_URL}/video/batch_status/${batchId}`);
                    
                    if (!response.ok) {
                        console.error(`Error fetching batch status: ${response.status}`);
                        batchStatusText.textContent = 'Error fetching batch status';
                        batchStatusText.className = 'status status-failed';
                        batchGenerateBtn.textContent = 'Generate Videos';
                        batchPollingActive = false;
                        return; // Stop polling
                    }
                    
                    const data = await response.json();
                    updateBatchUI(data);
                    
                    // Check if batch is complete, failed, or partial
                    if (data.status === 'complete' || data.status === 'failed' || data.status === 'partial') {
                        batchPollingActive = false;
                        batchGenerateBtn.textContent = 'Generate Videos';
                        
                        // Show download button if there are completed videos
                        if (data.completed > 0) {
                            batchDownloadContainer.style.display = 'block';
                            batchDownloadBtn.textContent = `Download All Videos (${data.completed})`;
                            batchDownloadBtn.onclick = () => {
                                window.location.href = `${API_BASE_URL}/video/batch_download/${batchId}`;
                            };
                        }
                        return; // Stop polling
                    } 
                    
                    // Continue polling
                    if (batchPollingActive) {
                        setTimeout(pollOnce, BATCH_POLL_INTERVAL);
                    }
                } catch (error) {
                    console.error('Error polling batch status:', error);
                    batchStatusText.textContent = `Error: ${error.message}`;
                    batchStatusText.className = 'status status-failed';
                    batchGenerateBtn.textContent = 'Generate Videos';
                    batchPollingActive = false;
                }
            };
            
            // Start polling
            pollOnce();
        }
        
        // Update batch UI with status data
        function updateBatchUI(data) {
            // Update batch status text
            batchStatusText.textContent = `${getStatusText(data.status)} (${data.completed}/${data.total} complete)`;
            batchStatusText.className = `status status-${data.status}`;
            
            // Update job status for each grid item
            if (data.jobs) {
                data.jobs.forEach((job, index) => {
                    // Get elements
                    const statusEl = document.getElementById(`batch-status-${index}`);
                    const progressEl = document.getElementById(`batch-progress-${index}`);
                    const videoEl = document.getElementById(`batch-video-${index}`);
                    
                    if (!statusEl || !progressEl || !videoEl) return;
                    
                    // Update status
                    statusEl.textContent = getStatusText(job.status);
                    statusEl.className = `status status-${job.status}`;
                    
                    // Update progress
                    progressEl.value = job.progress;
                    
                    // Show video if complete
                    if (job.status === 'complete') {
                        // Handle case where video_url might be missing
                        let finalVideoUrl = job.video_url;
                        if (!finalVideoUrl && job.job_id) {
                            // Use direct static path as instructed
                            finalVideoUrl = `/static/videos/${job.job_id}/video.mp4`;
                            console.log(`Using direct static path for job ${index}: ${finalVideoUrl}`);
                        }
                        
                        if (finalVideoUrl) {
                            // Try to load the video
                            videoEl.src = finalVideoUrl;
                            videoEl.style.display = 'block';
                            
                            // Handle video loading success
                            videoEl.onloadeddata = () => {
                                console.log(`Video for job ${index} loaded successfully`);
                            };
                            
                            // Simple error handler - since we're already using the direct path
                            videoEl.onerror = () => {
                                console.error(`Error loading video for job ${index} from ${finalVideoUrl}.`);
                                
                                // Try legacy format as fallback
                                if (job.job_id) {
                                    const fallbackUrl = `/static/videos/${job.job_id}.mp4`;
                                    console.log(`Trying fallback URL for job ${index}: ${fallbackUrl}`);
                                    videoEl.src = fallbackUrl;
                                    
                                    // Final error handler
                                    videoEl.onerror = () => {
                                        console.error(`Video loading failed for job ${index}`);
                                        console.log(`Expected video path: /static/videos/${job.job_id}/video.mp4`);
                                    };
                                }
                            };
                            
                            // Add download link underneath video with same URL as video source
                            const parent = videoEl.parentElement;
                            if (!document.getElementById(`download-${index}`)) {
                                const downloadLink = document.createElement('a');
                                downloadLink.id = `download-${index}`;
                                downloadLink.href = finalVideoUrl;
                                downloadLink.download = `video-${job.job_id}.mp4`;
                                downloadLink.textContent = 'Download Video';
                                downloadLink.className = 'button';
                                downloadLink.style.display = 'block';
                                downloadLink.style.marginTop = '10px';
                                downloadLink.style.textAlign = 'center';
                                parent.appendChild(downloadLink);
                                
                                // Update download link if video source changes
                                videoEl.addEventListener('loadeddata', () => {
                                    downloadLink.href = videoEl.src;
                                });
                            }
                        }
                    }
                });
            }
        }
        
        // -------------------- Prompt Enhancement --------------------
        
        // Get DOM elements for prompt enhancement
        const roughPrompt = document.getElementById('rough-prompt');
        const enhanceBtn = document.getElementById('enhance-btn');
        const enhancedResult = document.getElementById('enhanced-result');
        const enhancedPrompt = document.getElementById('enhanced-prompt');
        const useEnhancedBtn = document.getElementById('use-enhanced-btn');
        
        // Add event listeners
        enhanceBtn.addEventListener('click', enhancePrompt);
        useEnhancedBtn.addEventListener('click', () => {
            singlePrompt.value = enhancedPrompt.textContent;
            // Switch to single video tab
            document.getElementById('single-tab').click();
        });
        
        // Enhance prompt
        async function enhancePrompt() {
            const prompt = roughPrompt.value.trim();
            if (!prompt) {
                alert('Please enter a rough prompt to enhance');
                return;
            }
            
            enhanceBtn.disabled = true;
            enhanceBtn.innerHTML = 'Enhancing...<span class="loading"></span>';
            
            try {
                // Get current session ID (may be null for first request)
                const currentSessionId = getSessionId();
                
                const response = await fetch(`${API_BASE_URL}/enhance`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        rough_prompt: prompt,
                        session_id: currentSessionId
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Save session ID if it's new
                if (data.session_id) {
                    saveSessionId(data.session_id);
                }
                
                // Display the enhanced prompt
                enhancedPrompt.textContent = data.enhanced_prompt;
                enhancedResult.style.display = 'block';
                
            } catch (error) {
                console.error('Error enhancing prompt:', error);
                alert(`Error enhancing prompt: ${error.message}`);
            } finally {
                enhanceBtn.disabled = false;
                enhanceBtn.textContent = 'Enhance Prompt';
            }
        }
        
        // -------------------- Parameter Extraction --------------------
        
        // Get DOM elements for parameter extraction
        const parameterPrompt = document.getElementById('parameter-prompt');
        const extractBtn = document.getElementById('extract-btn');
        const parametersResult = document.getElementById('parameters-result');
        const parametersContainer = document.getElementById('parameters-container');
        
        // Current state for prompt management with session support
        let currentParameters = null;
        let promptHistory = [];
        let sessionId = null;
        
        // Try to get session ID from local storage
        function getSessionId() {
            if (!sessionId) {
                sessionId = localStorage.getItem('prompt_session_id');
                console.log(`Retrieved session ID from storage: ${sessionId}`);
            }
            return sessionId;
        }
        
        // Save session ID to local storage
        function saveSessionId(id) {
            if (id) {
                sessionId = id;
                localStorage.setItem('prompt_session_id', id);
                console.log(`Saved session ID to storage: ${id}`);
            }
        }
        
        // Add event listeners
        extractBtn.addEventListener('click', extractParameters);
        
        // Extract parameters
        async function extractParameters() {
            const prompt = parameterPrompt.value.trim();
            if (!prompt) {
                alert('Please enter a prompt to extract parameters from');
                return;
            }
            
            extractBtn.disabled = true;
            extractBtn.innerHTML = 'Extracting...<span class="loading"></span>';
            
            try {
                // Get current session ID or create new session
                const currentSessionId = getSessionId();
                
                const response = await fetch(`${API_BASE_URL}/initialize`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        prompt: prompt,
                        session_id: currentSessionId // May be null for first request
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Save or update session ID
                saveSessionId(data.session_id);
                
                // Store the current parameters
                currentParameters = data.parameters;
                
                // Update prompt history
                promptHistory = [{
                    prompt: data.prompt,
                    parameters: data.parameters,
                    description: 'Initial prompt'
                }];
                
                // Update the current prompt in the update tab
                document.getElementById('current-prompt').innerHTML = `<p>${data.prompt}</p>`;
                
                // Show session ID in the UI
                document.getElementById('current-prompt').innerHTML += `<p><small>Session ID: ${data.session_id}</small></p>`;
                
                // Update history in variations tab
                updateHistoryList();
                
                // Display the parameters
                displayParameters(data.parameters);
                parametersResult.style.display = 'block';
                
            } catch (error) {
                console.error('Error extracting parameters:', error);
                alert(`Error extracting parameters: ${error.message}`);
            } finally {
                extractBtn.disabled = false;
                extractBtn.textContent = 'Extract Parameters';
            }
        }
        
        // Display parameters in the UI
        function displayParameters(parameters) {
            parametersContainer.innerHTML = '';
            
            if (!parameters || Object.keys(parameters).length === 0) {
                parametersContainer.innerHTML = '<p>No parameters extracted.</p>';
                return;
            }
            
            for (const [key, value] of Object.entries(parameters)) {
                const paramItem = document.createElement('div');
                paramItem.className = 'parameter-item';
                
                const paramName = document.createElement('div');
                paramName.className = 'parameter-name';
                paramName.textContent = key;
                
                const paramValue = document.createElement('div');
                paramValue.className = 'parameter-value';
                paramValue.textContent = Array.isArray(value) ? value.join(', ') : value;
                
                paramItem.appendChild(paramName);
                paramItem.appendChild(paramValue);
                
                parametersContainer.appendChild(paramItem);
            }
        }
        
        // -------------------- Prompt Update --------------------
        
        // Get DOM elements for prompt updates
        const updateRequest = document.getElementById('update-request');
        const updateBtn = document.getElementById('update-btn');
        const updateResult = document.getElementById('update-result');
        const updatedPrompt = document.getElementById('updated-prompt');
        const changesContainer = document.getElementById('changes-container');
        const useUpdatedBtn = document.getElementById('use-updated-btn');
        
        // Add event listeners
        updateBtn.addEventListener('click', updatePrompt);
        useUpdatedBtn.addEventListener('click', () => {
            singlePrompt.value = updatedPrompt.textContent;
            // Switch to single video tab
            document.getElementById('single-tab').click();
        });
        
        // Update prompt
        async function updatePrompt() {
            if (!currentParameters) {
                alert('Please initialize a prompt first using the Parameter Extraction tab');
                document.getElementById('parameter-tab').click();
                return;
            }
            
            const request = updateRequest.value.trim();
            if (!request) {
                alert('Please enter an update request');
                return;
            }
            
            // Get the current session ID
            const currentSessionId = getSessionId();
            if (!currentSessionId) {
                alert('No session ID found. Please initialize a prompt first.');
                document.getElementById('parameter-tab').click();
                return;
            }
            
            updateBtn.disabled = true;
            updateBtn.innerHTML = 'Updating...<span class="loading"></span>';
            
            try {
                const response = await fetch(`${API_BASE_URL}/update`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_request: request,
                        session_id: currentSessionId
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Verify session ID matches
                if (data.session_id !== currentSessionId) {
                    console.warn(`Session ID mismatch: ${data.session_id} vs ${currentSessionId}`);
                    // Update our session ID if it changed
                    saveSessionId(data.session_id);
                }
                
                // Update current parameters
                currentParameters = data.parameters;
                
                // Add to prompt history
                promptHistory.push({
                    prompt: data.prompt,
                    parameters: data.parameters,
                    description: request
                });
                
                // Update history in variations tab
                updateHistoryList();
                
                // Display the updated prompt
                updatedPrompt.textContent = data.prompt;
                
                // Display changes
                displayChanges(data.changes);
                
                updateResult.style.display = 'block';
                
            } catch (error) {
                console.error('Error updating prompt:', error);
                alert(`Error updating prompt: ${error.message}`);
            } finally {
                updateBtn.disabled = false;
                updateBtn.textContent = 'Update Prompt';
            }
        }
        
        // Display changes in the UI
        function displayChanges(changes) {
            changesContainer.innerHTML = '';
            
            if (!changes || changes.length === 0) {
                changesContainer.innerHTML = '<p>No changes made.</p>';
                return;
            }
            
            for (const change of changes) {
                const changeItem = document.createElement('div');
                changeItem.className = 'change-item';
                changeItem.textContent = change;
                changesContainer.appendChild(changeItem);
            }
        }
        
        // -------------------- Prompt Variations --------------------
        
        // Get DOM elements for prompt variations
        const historyList = document.getElementById('history-list');
        const variationsCount = document.getElementById('variations-count');
        const generateVariationsBtn = document.getElementById('generate-variations-btn');
        const variationsResult = document.getElementById('variations-result');
        const variationsContainer = document.getElementById('variations-container');
        const useVariationBtn = document.getElementById('use-variation-btn');
        
        // Variations state
        let currentVariations = [];
        let selectedVariationIndex = -1;
        
        // Add event listeners
        generateVariationsBtn.addEventListener('click', generateVariations);
        useVariationBtn.addEventListener('click', () => {
            if (selectedVariationIndex >= 0 && selectedVariationIndex < currentVariations.length) {
                singlePrompt.value = currentVariations[selectedVariationIndex];
                // Switch to single video tab
                document.getElementById('single-tab').click();
            } else {
                alert('Please select a variation first');
            }
        });
        
        // Update history list
        function updateHistoryList() {
            historyList.innerHTML = '';
            
            if (!promptHistory || promptHistory.length === 0) {
                historyList.innerHTML = '<p>No prompt history yet. Please initialize and update prompts first.</p>';
                return;
            }
            
            // Use a stable array for selection tracking rather than checkbox IDs
            if (!window.selectedHistoryIndices) {
                window.selectedHistoryIndices = [];
            }
            
            for (let i = 0; i < promptHistory.length; i++) {
                const historyItem = document.createElement('div');
                historyItem.className = 'parameter-item';
                historyItem.style.marginBottom = '10px';
                
                // Create checkbox with unique ID
                const checkboxId = `history-check-${Date.now()}-${i}`;
                
                // Determine if this item is selected
                const isSelected = window.selectedHistoryIndices.includes(i);
                
                historyItem.innerHTML = `
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span style="font-weight: bold;">${i + 1}. ${promptHistory[i].description}</span>
                        <input type="checkbox" id="${checkboxId}" data-index="${i}" ${isSelected ? 'checked' : ''}>
                    </div>
                    <div style="font-size: 13px; max-height: 80px; overflow-y: auto;">${promptHistory[i].prompt}</div>
                `;
                historyList.appendChild(historyItem);
                
                // Add event listener for checkbox
                setTimeout(() => {
                    const checkbox = document.getElementById(checkboxId);
                    if (checkbox) {
                        checkbox.addEventListener('change', function() {
                            const index = parseInt(this.dataset.index);
                            if (this.checked) {
                                // Add to selected indices if not already present
                                if (!window.selectedHistoryIndices.includes(index)) {
                                    window.selectedHistoryIndices.push(index);
                                }
                            } else {
                                // Remove from selected indices
                                window.selectedHistoryIndices = window.selectedHistoryIndices.filter(idx => idx !== index);
                            }
                            console.log('Selected history indices:', window.selectedHistoryIndices);
                        });
                    }
                }, 0);
            }
        }
        
        // Generate variations
        async function generateVariations() {
            // If history isn't loaded, try to load it first
            if (!promptHistory || promptHistory.length === 0) {
                const currentSessionId = getSessionId();
                if (currentSessionId) {
                    try {
                        await loadSessionHistory(currentSessionId);
                        updateHistoryList();
                    } catch (e) {
                        console.error('Failed to load prompt history:', e);
                        alert('Please initialize a prompt first using the Parameter Extraction tab');
                        document.getElementById('parameter-tab').click();
                        return;
                    }
                } else {
                    alert('Please initialize a prompt first using the Parameter Extraction tab');
                    document.getElementById('parameter-tab').click();
                    return;
                }
            }
            
            // If still no history after attempted load, redirect to parameter tab
            if (!promptHistory || promptHistory.length === 0) {
                alert('Please initialize a prompt first using the Parameter Extraction tab');
                document.getElementById('parameter-tab').click();
                return;
            }
            
            // Get current session ID
            const currentSessionId = getSessionId();
            if (!currentSessionId) {
                alert('No session ID found. Please initialize a prompt first.');
                document.getElementById('parameter-tab').click();
                return;
            }
            
            // Use our stable array for selection tracking
            const selectedIndices = window.selectedHistoryIndices || [];
            
            if (selectedIndices.length === 0) {
                alert('Please select at least one prompt from the history');
                return;
            }
            
            // Validate that indices are still valid
            const validIndices = selectedIndices.filter(idx => idx >= 0 && idx < promptHistory.length);
            if (validIndices.length === 0) {
                alert('Selected prompt indices are no longer valid. Please select at least one prompt from the current history.');
                // Reset the selection
                window.selectedHistoryIndices = [];
                updateHistoryList();
                return;
            }
            
            // Use only valid indices
            if (validIndices.length !== selectedIndices.length) {
                console.warn(`Removed ${selectedIndices.length - validIndices.length} invalid indices`);
                window.selectedHistoryIndices = validIndices;
                updateHistoryList();
            }
            
            const count = parseInt(variationsCount.value);
            
            generateVariationsBtn.disabled = true;
            generateVariationsBtn.innerHTML = 'Generating...<span class="loading"></span>';
            
            try {
                console.log(`Generating ${count} variations based on ${selectedIndices.length} selected prompts`);
                
                const response = await fetch(`${API_BASE_URL}/generate-variations`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        selected_indices: validIndices, // Use validated indices
                        total_count: count,
                        session_id: currentSessionId
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Verify we received the expected number of variations
                if (data.prompts.length !== count) {
                    console.warn(`Expected ${count} variations but received ${data.prompts.length}`);
                }
                
                // Store variations
                currentVariations = data.prompts;
                selectedVariationIndex = -1;
                
                // Get information about which are original vs. new variations
                const originalIndices = validIndices.length;
                const newVariations = data.prompts.length - originalIndices;
                
                console.log(`Received ${originalIndices} original prompts and ${newVariations} new variations`);
                
                // Display variations with information about which are original vs. new
                displayVariations(data.prompts, validIndices.length);
                
                variationsResult.style.display = 'block';
                
            } catch (error) {
                console.error('Error generating variations:', error);
                alert(`Error generating variations: ${error.message}`);
            } finally {
                generateVariationsBtn.disabled = false;
                generateVariationsBtn.textContent = 'Generate Variations';
            }
        }
        
        // Display variations in the UI
        function displayVariations(variations, originalCount = 0) {
            variationsContainer.innerHTML = '';
            
            if (!variations || variations.length === 0) {
                variationsContainer.innerHTML = '<p>No variations generated.</p>';
                return;
            }
            
            // Count how many are original selected prompts vs newly generated variations
            const count = parseInt(variationsCount.value);
            const newCount = variations.length - originalCount;
            const displayText = `Showing ${variations.length} results: ${originalCount} original + ${newCount} new variations`;
            
            // Add header with count information
            const headerDiv = document.createElement('div');
            headerDiv.style.width = '100%';
            headerDiv.style.marginBottom = '15px';
            headerDiv.style.fontWeight = 'bold';
            headerDiv.textContent = displayText;
            variationsContainer.appendChild(headerDiv);
            
            // Create grid for variations
            for (let i = 0; i < variations.length; i++) {
                const variationItem = document.createElement('div');
                variationItem.className = 'variation-item';
                variationItem.dataset.index = i;
                
                // Add a number label to help identify each variation
                const numberLabel = document.createElement('div');
                numberLabel.style.fontWeight = 'bold';
                numberLabel.style.marginBottom = '5px';
                
                // Special styling for original vs. generated variations
                if (i < originalCount) {
                    // Original prompt
                    numberLabel.textContent = `Original ${i + 1}`;
                    numberLabel.style.color = '#4CAF50';
                    variationItem.style.backgroundColor = '#E8F5E9';
                    variationItem.style.borderColor = '#4CAF50';
                } else {
                    // New variation
                    numberLabel.textContent = `New Variation ${i + 1 - originalCount}`;
                    numberLabel.style.color = '#2196F3';
                }
                
                // Container for the prompt text
                const promptText = document.createElement('div');
                promptText.textContent = variations[i];
                
                // Handle fallback variations
                if (variations[i].includes('(fallback') || variations[i].includes('(substitute')) {
                    variationItem.style.backgroundColor = '#fff3e0';
                    variationItem.style.borderColor = '#ff9800';
                    numberLabel.textContent += ' (fallback)';
                    numberLabel.style.color = '#ff9800';
                }
                
                variationItem.appendChild(numberLabel);
                variationItem.appendChild(promptText);
                
                variationItem.addEventListener('click', () => {
                    // Remove selected class from all items
                    document.querySelectorAll('.variation-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    
                    // Add selected class to clicked item
                    variationItem.classList.add('selected');
                    selectedVariationIndex = i;
                });
                
                variationsContainer.appendChild(variationItem);
            }
        }
        
        // -------------------- Session Management --------------------
        
        // Get DOM elements for session management
        const currentSessionId = document.getElementById('current-session-id');
        const newSessionBtn = document.getElementById('new-session-btn');
        const clearSessionBtn = document.getElementById('clear-session-btn');
        const listSessionsBtn = document.getElementById('list-sessions-btn');
        const sessionsList = document.getElementById('sessions-list');
        
        // Add event listeners
        newSessionBtn.addEventListener('click', createNewSession);
        clearSessionBtn.addEventListener('click', clearSessionData);
        listSessionsBtn.addEventListener('click', listAllSessions);
        
        // Update session info display
        function updateSessionDisplay() {
            const sid = getSessionId();
            currentSessionId.textContent = sid || 'None';
        }
        
        // Call this when the session tab is clicked
        document.getElementById('session-tab').addEventListener('click', updateSessionDisplay);
        
        // Also update session display when the document is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Update session display when the page loads
            updateSessionDisplay();
            
            // If we have a saved session ID, try to load its data
            const savedSessionId = getSessionId();
            if (savedSessionId) {
                console.log(`Found saved session ID: ${savedSessionId}`);
                try {
                    // Load session history but don't await it - let it run in background
                    loadSessionHistory(savedSessionId);
                } catch (e) {
                    console.warn("Could not load saved session history:", e);
                }
            }
        });
        
        // Create a new session
        async function createNewSession() {
            try {
                // Clear existing session ID
                localStorage.removeItem('prompt_session_id');
                sessionId = null;
                
                // Make a request to initialize with null session ID to get a new one
                const response = await fetch(`${API_BASE_URL}/initialize`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        prompt: "A new session with a placeholder prompt",
                        session_id: null // Explicitly request a new session
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Save the new session ID
                saveSessionId(data.session_id);
                
                // Update display
                updateSessionDisplay();
                alert(`New session created with ID: ${data.session_id}`);
                
            } catch (error) {
                console.error('Error creating new session:', error);
                alert(`Error creating new session: ${error.message}`);
            }
        }
        
        // Clear session data
        function clearSessionData() {
            if (confirm('Are you sure you want to clear the current session data? This will remove the session ID from your browser but the session will still exist on the server.')) {
                localStorage.removeItem('prompt_session_id');
                sessionId = null;
                
                // Reset local state
                currentParameters = null;
                promptHistory = [];
                
                // Update display
                updateSessionDisplay();
                alert('Session data cleared from browser.');
            }
        }
        
        // List all active sessions
        async function listAllSessions() {
            try {
                // Show loading state
                sessionsList.innerHTML = '<p>Loading sessions...</p>';
                sessionsList.style.display = 'block';
                
                const response = await fetch(`${API_BASE_URL}/sessions`);
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Display sessions
                if (!data.sessions || Object.keys(data.sessions).length === 0) {
                    sessionsList.innerHTML = '<p>No active sessions found.</p>';
                    return;
                }
                
                // Create a table to display sessions
                let tableHtml = `
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="text-align: left; padding: 8px; border-bottom: 1px solid #ddd;">Session ID</th>
                                <th style="text-align: left; padding: 8px; border-bottom: 1px solid #ddd;">Last Accessed</th>
                                <th style="text-align: left; padding: 8px; border-bottom: 1px solid #ddd;">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                for (const [sid, lastAccessed] of Object.entries(data.sessions)) {
                    const date = new Date(lastAccessed * 1000).toLocaleString();
                    
                    tableHtml += `
                        <tr>
                            <td style="padding: 8px; border-bottom: 1px solid #eee;">${sid}</td>
                            <td style="padding: 8px; border-bottom: 1px solid #eee;">${date}</td>
                            <td style="padding: 8px; border-bottom: 1px solid #eee;">
                                <button onclick="useSession('${sid}')" style="padding: 5px 10px; margin-right: 5px;">Use</button>
                                <button onclick="deleteSession('${sid}')" style="padding: 5px 10px; background-color: #f44336;">Delete</button>
                            </td>
                        </tr>
                    `;
                }
                
                tableHtml += `
                        </tbody>
                    </table>
                `;
                
                sessionsList.innerHTML = tableHtml;
                
            } catch (error) {
                console.error('Error listing sessions:', error);
                sessionsList.innerHTML = `<p>Error loading sessions: ${error.message}</p>`;
            }
        }
        
        // Use a specific session
        async function useSession(sid) {
            try {
                // Save the session ID
                saveSessionId(sid);
                
                // Update display
                updateSessionDisplay();
                
                // Load prompt history for this session
                await loadSessionHistory(sid);
                
                alert(`Now using session: ${sid}`);
            } catch (error) {
                console.error('Error using session:', error);
                alert(`Error using session: ${error.message}`);
            }
        }
        
        // Delete a session
        async function deleteSession(sid) {
            if (confirm(`Are you sure you want to delete session ${sid}? This cannot be undone.`)) {
                try {
                    const response = await fetch(`${API_BASE_URL}/session/${sid}`, {
                        method: 'DELETE'
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status}`);
                    }
                    
                    // If we deleted the current session, clear local storage
                    if (sid === getSessionId()) {
                        localStorage.removeItem('prompt_session_id');
                        sessionId = null;
                        updateSessionDisplay();
                    }
                    
                    // Refresh the sessions list
                    await listAllSessions();
                    
                    alert(`Session ${sid} deleted successfully`);
                    
                } catch (error) {
                    console.error('Error deleting session:', error);
                    alert(`Error deleting session: ${error.message}`);
                }
            }
        }
        
        // Load prompt history for a session
        async function loadSessionHistory(sid) {
            try {
                // Use POST method as required by updated API
                const response = await fetch(`${API_BASE_URL}/history`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: sid
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Update prompt history
                promptHistory = data.history || [];
                
                // Update the current prompt if there's any history
                if (promptHistory.length > 0) {
                    const latestPrompt = promptHistory[promptHistory.length - 1];
                    currentParameters = latestPrompt.parameters;
                    
                    // Update the current prompt in the update tab
                    document.getElementById('current-prompt').innerHTML = `
                        <p>${latestPrompt.prompt}</p>
                        <p><small>Session ID: ${sid}</small></p>
                    `;
                    
                    // Also try to load current parameters separately to ensure we have latest
                    try {
                        await loadCurrentParameters(sid);
                    } catch (paramError) {
                        console.warn("Could not load current parameters:", paramError);
                        // Continue with the parameters from history
                    }
                }
                
                // Update history in variations tab
                updateHistoryList();
                
                return promptHistory;
                
            } catch (error) {
                console.error('Error loading session history:', error);
                return [];
            }
        }
        
        // Load current parameters for a session
        async function loadCurrentParameters(sid) {
            try {
                // Use POST method as required by updated API
                const response = await fetch(`${API_BASE_URL}/parameters`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: sid
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Update current parameters
                if (data.parameters) {
                    currentParameters = data.parameters;
                }
                
                return currentParameters;
                
            } catch (error) {
                console.error('Error loading current parameters:', error);
                throw error;
            }
        }
        
        // Expose functions to global scope for the onclick handlers
        window.useSession = useSession;
        window.deleteSession = deleteSession;
        
        // Initialize the session display
        updateSessionDisplay();
        
        // -------------------- Helper Functions --------------------
        
        // Format status text
        function getStatusText(status) {
            const statusMap = {
                'pending': 'Waiting to start...',
                'generating': 'Generating video...',
                'processing': 'Processing video...',
                'complete': 'Video complete!',
                'failed': 'Generation failed',
                'partial': 'Partially complete'
            };
            return statusMap[status] || status;
        }
    </script>
</body>
</html>